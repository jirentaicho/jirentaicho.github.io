{"pageProps":{"frontMatter":{"title":"ゼロからのOS自作入門 | day02","date":"2021.12.02","description":"ゼロからのOS自作入門 | day02","categories":["OS"]},"content":"<p>前回はハローワールドを表示するOSの起動まで行いました。今回はEDKⅡとメモリマップについてです。</p>\n<p>前回の開発環境構築でedk2フォルダが作成されています。</p>\n<h3>用語整理</h3>\n<p>まずは用語を整理します。というかこの辺の用語全然わからない。私はノートパソコンのメモリ増設と、BTOデスクトップのSSD増設くらいしかしたことないにわかです。</p>\n<p>UEFI</p>\n<p>従来のBIOSでは古いよってことで従来のBIOSと代わるものとして採用されたそうですが、完全なBIOSの代替というわけではないようですが、新しいBIOSのような認識なのでしょう</p>\n<p>ちなみに私のパソコンはBIOSモードがUEFIになってました</p>\n<p><img src=\"/225/1.png\" alt=\"画像\"></p>\n<p>EDK２</p>\n<p>UEFIとその周辺のプログラムを実装したオープンソースで、UEFIの開発にも、UEFIで動くアプリの開発にも使える”開発キット”だそうです。</p>\n<p>BIOS</p>\n<p>そもそもBIOSってのは、OSが起動する前にキーボードやマウス、CPUの管理制御を行うものだそうです。つまりハードウェアの管理と制御</p>\n<p>ブートローダ</p>\n<p>コンピュータを起動したときに、OSなどを動かすためのプログラム。ハードディスクにあるOSをメインメモリにロードする。</p>\n<p>BIOSがブートローダを呼出し、ブートローダがOSを呼出すような動きです。</p>\n<p>この書籍ではUSBメモリからメインメモリにOSをロードします。</p>\n<p>メインメモリ</p>\n<p>CPUが直接データを読み書きできるデータの一時保存場所</p>\n<p>OS</p>\n<p>今回の書籍で作るものですね。ユーザーやアプリケーションと、ハードウェアの中間に位置するもの。</p>\n<p>マウスを動かすというインターフェースを提供するし、画面に表示するのようなインターフェースも提供するようなもの。かしらね。</p>\n<p>OVMF</p>\n<p>Open Virtual Machine Firmwareは仮想マシンでUEFI を使えるようにするプロジェクトです。</p>\n<p>参考：OVMF による PCI パススルー</p>\n<h3>ブートローダの作成</h3>\n<p>用語を整理することでなんとなくやろうとしていることが理解できた。</p>\n<p>まずEDK2の開発キット（ライブラリ）を使ってOSを作っていきます。</p>\n<p>で、まずやることはOSをメインメモリにロードするためのブートローダを作成する。</p>\n<h3>ビルドに必要な設定を参考書通りに行う</h3>\n<p>workspaceでチェックアウトする。。。え？いつ作ったんそれ？開発環境構築でクローンはしてきたけどworkspaceフォルダにやってないような・・・？</p>\n<p>そもそもこれって開発環境じゃなくて、mikanos本体のリポジトリですよね？クローンしてくれなんてどこに記載があるんだろうか・・・Kindleの検索機能も使えないのがまじで辛い</p>\n<p>ここで付録Bを見る</p>\n<p>ここにいろいろ書いてありました。</p>\n<p>MikanOSをビルドするには開発環境に加えてMikanOSそのもののソースコードも必要</p>\n<p>MikanOSのソースコードはどこに配置してもOKで例としてworkspaceを利用します。→本はしっかり付録から読みましょう。。。？？？</p>\n<p>気を取り直して付録通りにクローンしたら本章のday02に戻ってチェックアウトします。</p>\n<p>ここでようやくMain.Cが参考書通りに記載されているのを確認。</p>\n<p>edk2フォルダ（開発環境）に対して、$HOME/workspace/mikanos/MikanLoaderPkg（ソースコード）へのシンボリックリンクを張ります。</p>\n<p>ln -s です。Windowsでいうところのショートカット作成のようなもの。</p>\n<p>ls -lで確認</p>\n<p><img src=\"/225/2.png\" alt=\"画像\"></p>\n<p>失敗すると赤で表示されます</p>\n<p><img src=\"/225/3.png\" alt=\"画像\"></p>\n<p>Conf/target.txtの作成と、ビルドの設定、EDK２のビルドコマンドの実施まで行う。ビルドはズラーっと長文が流れます。</p>\n<p>target.txtにてACTIVE_PLATFORM = MikanLoaderPkg/MikanLoaderPkg.dscとしていますので、先ほどのedk2に張ったシンボリックリンクが有効なら、ソースコードのほうを参照してくれるという感じです。</p>\n<p>efiファイルができたのでエミュレータで起動してみます。</p>\n<p>起動</p>\n<p>前回やったのですが、ほとんど覚えてないので再確認します。</p>\n<p>devenvのrun_qemu.shを起動したのだ。というわけで以下で実施</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">$HOME/osbook/devenv/run_qemu.sh Loader.efi</code></pre></div>\n<p><img src=\"/225/4.png\" alt=\"画像\"></p>\n<p>上手く動いてることを確認</p>\n<h2>メモリマップとは</h2>\n<p>メモリマップとはメインメモリのどの部分が何に使われているか記載した地図。つまりデータがメインメモリのどこにどのように記録されているのか。</p>\n<p>https://www.kushiro-ct.ac.jp/yanagawa/pl2b-2018/01.html</p>\n<h3>メモリマップを取得するプログラム</h3>\n<p>とりあえずブランチ変えてビルドするだけでは意味ないのでソースを追ってみます。今回のソースは以下のソース</p>\n<p>https://github.com/uchan-nos/mikanos/blob/osbook_day02b/MikanLoaderPkg/Main.c</p>\n<p>さて、この章を読んで気が付いた。</p>\n<p>「C言語がわからない」ドンッ！</p>\n<p>とりあえずざっと読んで構造体とかポインタとかに目を通す。</p>\n<p>https://www.tohoho-web.com/ex/c-lang.html</p>\n<p>ポインタ</p>\n<p>変数など宣言したときに、その変数のメモリ上のアドレスを取得するときに利用する。</p>\n<p>変数aのポインタは int <em>b = &#x26;a;のようにすれば</em>bにはaのポインタが格納される。</p>\n<p>値渡しと参照渡し</p>\n<p>関数に引数を渡す際の渡し方。Javaではできないようなことですな。たしかオブジェクトを渡したときに参照の値渡しになるので引数のオブジェクトをメソッド内で再代入しても呼出し下では変化がない。(ojc.list = newlistはできる）</p>\n<p>Cの場合は参照を渡せるのですね？</p>\n<p>void hoge(int *x) { *x = 10 }</p>\n<p>構造体(struct)</p>\n<p>メンバ変数のみを定義できるclassのようなもの(ふむふむ)型と変数名のセットを,で区切って定義する。</p>\n<p>ポインタを返す関数</p>\n<p>戻り値の型に*をつける</p>\n<p>const CHAR16* GetMemoryTypeUnicode(EFI_MEMORY_TYPE type)</p>\n<p>構造体の初期化</p>\n<p>https://yu-nix.com/blog/2020/8/7/c-struct-init/</p>\n<p>ようやくソースコードを見ます。。</p>\n<p>とりあえず入り口であるUefiMainメソッドを見ると</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">  CHAR8 memmap_buf[4096 * 4];\n  struct MemoryMap memmap = {sizeof(memmap_buf), memmap_buf, 0, 0, 0, 0};\n  GetMemoryMap(&#x26;amp;memmap);</code></pre></div>\n<p>まずは構造体を初期化してメモリマップを取得するメソッドに構造体のポインタを渡します。</p>\n<p>GetMemoryMapメソッドはgBSというブートサービスを表すグローバル変数です。とりあえずこれでメモリマップを取得でき、MemoryMapで指定されたメモリ領域に書き込みます。</p>\n<p>あとはファイルへの保存とかみたいです。</p>\n<p>早速ビルドしてみます。</p>\n<p><img src=\"/225/5.png\" alt=\"画像\"></p>\n<p>次いでに作成されたdisc.imgをマウントして中身を見てみます</p>\n<p><img src=\"/225/6.png\" alt=\"画像\"></p>\n<p>その後はポインタの説明で二章終わり。</p>\n<h2>ポインタ</h2>\n<p>以下のようなコードでポインタを少し理解する</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">#include &#x26;lt;stdio.h&#x26;gt;\n\nint main(void)\n{\n\t// %pはポインタ　%dはint\n\tint i = 10;\n\tprintf(&#x26;quot;iの値 = %d \\n&#x26;quot;, i);\n\tprintf(&#x26;quot;iのポインタ = %p \\n&#x26;quot;, &#x26;amp;i);\n\n\tint* p = &#x26;amp;i;\n\tprintf(&#x26;quot;iのポインタ変数p = %p \\n&#x26;quot;, p);\n\n\tint r = *p;\n\tprintf(&#x26;quot;iのポインタ変数pを代入したｒ = %d \\n&#x26;quot;, r);\n\n\t*p = 99;\n\tprintf(&#x26;quot;iのポインタ変数pに99を代入しました \\n&#x26;quot;);\n\n\tprintf(&#x26;quot;iの値 = %d \\n&#x26;quot;, i);\n\n\tgetchar();\n\n\treturn 0;\n}</code></pre></div>\n<p>出力結果は以下です</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">iの値 = 10\niのポインタ = 0053FAB8\niのポインタ変数p = 0053FAB8\niのポインタ変数pを代入したｒ = 10\niのポインタ変数pに99を代入しました\niの値 = 99</code></pre></div>\n<p>・ポインタは整数と変換できます。</p>\n<p>・ポインタのポインタを利用して値を変更することもテクニックとしてありよく使います。</p>\n<h3>サイトなど</h3>\n<p>https://osdev-jp.readthedocs.io/ja/latest/2017/create-uefi-app-with-edk2.html#</p>\n<h3>思ったこと</h3>\n<p>・時間かかりすぎているし理解度が低い。これって一通りやって何週かしたほうがいいのかな？</p>\n<p>・私の読み方が悪い？どうやって手を動かすべきなのか散らばりすぎてる印象。→ようやくこの辺は落ち着いてきた。</p>\n<p>・ここまではGithubでクローンとかするのはいいんだけど、なんか端折りすぎていて探すのに時間がかかった</p>","slug":"p225"},"__N_SSG":true}