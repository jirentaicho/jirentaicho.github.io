{"pageProps":{"frontMatter":{"title":"ゼロからのOS自作入門 | day03","date":"2021.12.03","description":"ゼロからのOS自作入門 | day03","categories":["OS"]},"content":"<p>Kubernetesの沼にハマったムッキー！</p>\n<p>Kubernetes大嫌いです。さてday03やっていきます</p>\n<p>前回はメモリマップを読み込んでみるということをしました。正直いってほとんど理解してないですが、読み進めていきます。</p>\n<p>今回は画面を塗りつぶしたOS本体を作りブートローダーで呼び出すことをやります。</p>\n<h2>レジスタ</h2>\n<p>CPUに内蔵されている記憶領域で、汎用レジスタと特殊レジスタがある。</p>\n<p>汎用レジスタは一般の演算、値を記憶します。特殊レジスタはCPUの設定を行う</p>\n<p>外部のメインメモリと汎用レジスタは目的が同じでも速度が違う。もちろん汎用レジスタのほうが早い</p>\n<p>参考サイト</p>\n<p><a href=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Ftryunoo.hatenablog.com%2Fentry%2F2017%2F10%2F15%2F220724\">参考</a></p>\n<h3>汎用レジスタ</h3>\n<p>汎用レジスタで演算を行うには</p>\n<p>add rax, rbx (rax += rbx)</p>\n<p>の用に記載する。</p>\n<p>汎用レジスタは64ビットだが、区分けしてより小さい型を使えるようになっている</p>\n<p>例えばRAX(64ビット)のうち、EAXを32ビット、AXを16ビット、AHとALを8ビットとして扱える。</p>\n<h3>特殊レジスタ</h3>\n<p>値を読み書きすること自体に意味があったり、各ビットによって役割が異なるなどの特徴がある。</p>\n<p>RIP(命令ポインタレジスタ)は次に実行する命令のメモリアドレスを保持RFLAGS(フラグレジスタ)は命令の実行結果によって変化するフラグを集めるCR0(制御レジスタ?)はCPUの重要な設定を集める</p>\n<p>この辺を読んでいたらこの動画を思い出した。</p>\n<p><a href=\"https://www.youtube.com/embed/LsDoLuClfFM?feature=oembed\">参考</a></p>\n<h2>カーネル</h2>\n<p>この本ではブートローダはUEFIアプリとして作るが、カーネルはELFバイナリとして別々に作っていくそうです。</p>\n<p>カーネルに関してはUEFIの規格から自由になるためだそうです。</p>\n<p>C++でC言語風に関数定義するにはextern “C”という記載をします。マングリングを防ぐ。</p>\n<p><em><strong>asm</strong></em>()は、C言語にアセンブリ言語の命令を埋め込む方法です。</p>\n<p>hltはCPUに割り込みがない限りCPUを停止するコマンドです。</p>\n<p>C++の動作環境はホスト環境とフリースタンディング環境があり、フリースタンディング環境向けにコンパイルする→OS自体はOSがない環境だから</p>\n<p>前も出てきたリンカがまた出てきた。</p>\n<p>ld.lldによってオブジェクトファイルから実行可能ファイルを作る。流れとしては.cpp→.o→.elfですね</p>\n<h3>とりあえず進める</h3>\n<p><img src=\"/304/1.png\" alt=\"画像\"></p>\n<p>なんかgitの設定がバグってる・・・？</p>\n<p><img src=\"/304/2.png\" alt=\"画像\"></p>\n<p>いつできたのかわからんので消します・・・</p>\n<p><img src=\"/304/3.png\" alt=\"画像\"></p>\n<p>上手く戻せたと思う</p>\n<p><img src=\"/304/4.png\" alt=\"画像\"></p>\n<p>-02オプション付けると、そんなのないって怒られてしまったので外しました</p>\n<p><img src=\"/304/5.png\" alt=\"画像\"></p>\n<p>elfの作成まで完了</p>\n<p><img src=\"/304/6.png\" alt=\"画像\"></p>\n<p>本の通り進めてるとうまくいかないので、source edksetup.shを実行しました。（あってんのかな？）</p>\n<p><img src=\"/304/7.png\" alt=\"画像\"></p>\n<p>なんどかinfo registersをやってRIPの値が変わっていないことが確認できたので、永久ループしているようです（あれこれって駄目なんだっけ？）</p>\n<p><img src=\"/304/8.png\" alt=\"画像\"></p>\n<p>メモリマップを確認してみる</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">sudo mount -o loop disk.img mnt\n[sudo] misaka のパスワード: \nmisaka@misaka:~/edk2$ cat mnt/memmap\nIndex, Type, Type(name), PhysicalStart, NumberOfPages, Attribute\n0, 3, EfiBootServicesCode, 00000000, 1, F\n1, 7, EfiConventionalMemory, 00001000, 9F, F\n2, 7, EfiConventionalMemory, 00100000, 700, F\n3, A, EfiACPIMemoryNVS, 00800000, 8, F\n4, 7, EfiConventionalMemory, 00808000, 8, F\n5, A, EfiACPIMemoryNVS, 00810000, F0, F\n6, 4, EfiBootServicesData, 00900000, B00, F\n7, 7, EfiConventionalMemory, 01400000, 3AB36, F\n8, 4, EfiBootServicesData, 3BF36000, 20, F\n9, 7, EfiConventionalMemory, 3BF56000, 270B, F\n10, 1, EfiLoaderCode, 3E661000, 3, F\n11, 4, EfiBootServicesData, 3E664000, 219, F\n12, 3, EfiBootServicesCode, 3E87D000, B7, F\n13, A, EfiACPIMemoryNVS, 3E934000, 12, F\n14, 0, EfiReservedMemoryType, 3E946000, 1C, F\n15, 3, EfiBootServicesCode, 3E962000, 10A, F\n16, 6, EfiRuntimeServicesData, 3EA6C000, 5, F\n17, 5, EfiRuntimeServicesCode, 3EA71000, 5, F\n18, 6, EfiRuntimeServicesData, 3EA76000, 5, F\n19, 5, EfiRuntimeServicesCode, 3EA7B000, 5, F\n20, 6, EfiRuntimeServicesData, 3EA80000, 5, F\n21, 5, EfiRuntimeServicesCode, 3EA85000, 7, F\n22, 6, EfiRuntimeServicesData, 3EA8C000, 8F, F\n23, 4, EfiBootServicesData, 3EB1B000, 4DA, F\n24, 7, EfiConventionalMemory, 3EFF5000, 4, F\n25, 4, EfiBootServicesData, 3EFF9000, 6, F\n26, 7, EfiConventionalMemory, 3EFFF000, 1, F\n27, 4, EfiBootServicesData, 3F000000, A1B, F\n28, 7, EfiConventionalMemory, 3FA1B000, 1, F\n29, 3, EfiBootServicesCode, 3FA1C000, 17F, F\n30, 5, EfiRuntimeServicesCode, 3FB9B000, 30, F\n31, 6, EfiRuntimeServicesData, 3FBCB000, 24, F\n32, 0, EfiReservedMemoryType, 3FBEF000, 4, F\n33, 9, EfiACPIReclaimMemory, 3FBF3000, 8, F\n34, A, EfiACPIMemoryNVS, 3FBFB000, 4, F\n35, 4, EfiBootServicesData, 3FBFF000, 201, F\n36, 7, EfiConventionalMemory, 3FE00000, 8D, F\n37, 4, EfiBootServicesData, 3FE8D000, 20, F\n38, 3, EfiBootServicesCode, 3FEAD000, 20, F\n39, 4, EfiBootServicesData, 3FECD000, 9, F\n40, 3, EfiBootServicesCode, 3FED6000, 1E, F\n41, 6, EfiRuntimeServicesData, 3FEF4000, 84, F\n42, A, EfiACPIMemoryNVS, 3FF78000, 88, F\n43, 6, EfiRuntimeServicesData, FFC00000, 400, 1\n</code></pre></div>\n<p>なるほど、そろそろ２進数とか１６進数を覚える必要があるということですか。</p>\n<p>EfiConventionalMemoryというのが十分な大きさのあるメモリだそうです？？</p>\n<p>まず前提として、AllocatePagesは確実に確保されたメモリのアドレスを指定する必要がある。</p>\n<p>今回はカーネルファイルをメモリの0x100000番地に配置しているので、ここが空いている必要があるということです。</p>\n<p>ん？0x100000番地ってどれ？</p>\n<p>0xってのは16進数のことなのね。ってことは100000をなんとかして解読すればいいのか？</p>\n<p>これか？これでいいのか？空いてるぞ？？なにをどうしたらいいのかわからないのでとりあえず進めてみる。。</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">2, 7, EfiConventionalMemory, 00100000, 700, F</code></pre></div>\n<p>ちなみにソースで0x100000を指定しているのは以下で表しています。</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">  EFI_PHYSICAL_ADDRESS kernel_base_addr = 0x100000;\n  gBS-&#x26;gt;AllocatePages(\n      AllocateAddress, EfiLoaderData,\n      (kernel_file_size + 0xfff) / 0x1000, &#x26;amp;kernel_base_addr);\n</code></pre></div>\n<p>kernel_file_size + 0xfff) / 0x1000ではkernel_file_sizeがバイト単位なのでページ単位に変換する</p>\n<p>UEFIにおけるページ単位の大きさが４Kib=0x1000で切り上げのため0xfffをプラスしている。</p>\n<p>→この説明で理解できるほど頭良くないぜ☆とりあえずUEFIではページ単位でメモリとかやれってことかい？</p>\n<p>とりあえずあとで読みます</p>\n<p>とりあえずRIPが指すアドレスに入っている命令を調べる必要がある。書籍では</p>\n<p>RIP=0000000000101011となっており、RPIが指すメモリ領域を x / 2i 0x101011 で表示していた</p>\n<p>→なるほど、まったくわからん。とりあえず１６進数の0xを頭につけてx/2iすりゃいいのか？やってみることにします。私の場合は</p>\n<p>RIP=000000000010100a</p>\n<p>なのでx /2i 0x10100aを入力してみる</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">(qemu) x /2i 0x10100a\n0x0010100a:  e9 fa ff ff ff           jmp      0x101009\n0x0010100f:  cc                       int3   </code></pre></div>\n<p>ん？書籍と同じようにjmpしてるので、そこを調べる。</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">(qemu) x /2i 0x101009\n0x00101009:  f4                       hlt      \n0x0010100a:  e9 fa ff ff ff           jmp      0x101009</code></pre></div>\n<p>ん？hltあるぞ？これってうまくいってる証拠じゃなかったか？</p>\n<p>永久ループで止まっているのが正解なのか？それともて永久ループしているのが正解なのか？わからんが、もはや進めるしかない。。ついでにjmpも調べてみるか・・・ってこれ同じってことは永久ループしてるってことでいいんですよね？あれ書籍と同じなんですが。。。これって正解なんですか？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">(qemu) x /2i 0x10100a\n0x0010100a:  e9 fa ff ff ff           jmp      0x101009\n0x0010100f:  cc                       int3     \n(qemu) x /2i 0x101009\n0x00101009:  f4                       hlt      \n0x0010100a:  e9 fa ff ff ff           jmp      0x101009\n(qemu) x /2i 0x101009\n0x00101009:  f4                       hlt      \n0x0010100a:  e9 fa ff ff ff           jmp      0x101009\n</code></pre></div>\n<p>というわけでRIPの値が変わってないですが先に進めます</p>\n<p>ループ書いてループしてんなら、ええやろ☆</p>\n<h2>レッドゾーン</h2>\n<p>カーネルのコンパイルオプション -mno-red-zoneの説明が入りますが、読んでもわからんのでスルーします。とりあえず開発中はレッドゾーンを無効にしておくのが良いそうです。</p>\n<h2>ブートローダからピクセル描画</h2>\n<p>UEFIのGOPを使ってピクセル描画します。</p>\n<p>１ピクセルが８ビットなら２５６色、各色８ビットなら１６７７万色の表示が可能</p>\n<p><img src=\"/304/9.png\" alt=\"画像\"></p>\n<h2>カーネルからピクセルを描画</h2>\n<p>今度はカーネルに処理を書くので書いたら、ブートローダからフレームバッファの先頭アドレスとサイズという情報をカーネルに渡します。</p>\n<p>また、新しく環境変数を設定します</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">misaka@misaka:~/workspace/mikanos/kernel$ echo $CPPFLAGS\n\nmisaka@misaka:~/workspace/mikanos/kernel$ source $HOME/osbook/devenv/buildenv.sh\nmisaka@misaka:~/workspace/mikanos/kernel$ echo $CPPFLAGS\n-I/home/misaka/osbook/devenv/x86_64-elf/include/c++/v1 -I/home/misaka/osbook/devenv/x86_64-elf/include -I/home/misaka/osbook/devenv/x86_64-elf/include/freetype2 -I/home/misaka/edk2/MdePkg/Include -I/home/misaka/edk2/MdePkg/Include/X64 -nostdlibinc -D__ELF__ -D_LDBL_EQ_DBL -D_GNU_SOURCE -D_POSIX_TIMERS -DEFIAPI=&#x26;#39;__attribute__((ms_abi))&#x26;#39;\n</code></pre></div>\n<p>ソースのuintとunitって書いててエラー起きたので誤字には気をつけますということでコンパイルします。</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">misaka@misaka:~/workspace/mikanos/kernel$ clang++ $CPPFLAGS --target=x86_64-elf -fno-exceptions -ffreestanding -c main.cpp\nmain.cpp:2:28: error: unknown type name &#x26;#39;unit64_t&#x26;#39;\nextern &#x26;quot;C&#x26;quot; void KernelMain(unit64_t frame_buffer_base, unit64_t frame_buffer_size) {\n                           ^\nmain.cpp:2:56: error: unknown type name &#x26;#39;unit64_t&#x26;#39;\nextern &#x26;quot;C&#x26;quot; void KernelMain(unit64_t frame_buffer_base, unit64_t frame_buffer_size) {\n                                                       ^\nmain.cpp:3:1: error: unknown type name &#x26;#39;unit8_t&#x26;#39;\nunit8_t* frame_buffer = reinterpret_cast&#x26;lt;unit8_t*&#x26;gt;(frame_buffer_base);\n^\nmain.cpp:3:42: error: unknown type name &#x26;#39;unit8_t&#x26;#39;\nunit8_t* frame_buffer = reinterpret_cast&#x26;lt;unit8_t*&#x26;gt;(frame_buffer_base);\n                                         ^\nmain.cpp:4:5: error: unknown type name &#x26;#39;unit64_t&#x26;#39;\nfor(unit64_t i = 0; i &#x26;lt; frame_buffer_size; ++i){\n    ^\n5 errors generated.\nmisaka@misaka:~/workspace/mikanos/kernel$ clang++ $CPPFLAGS --target=x86_64-elf -fno-exceptions -ffreestanding -c main.cpp\n</code></pre></div>\n<p>また、新しい環境変数を使ってelfを作る</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">misaka@misaka:~/workspace/mikanos/kernel$ ld.lld $LDFLAGS --entry KernelMain -z norelro --image-base 0x100000 --static -o kernel.elf main.o</code></pre></div>\n<p>ブートローダの記載を終えたらbuildコマンドでビルドして、いつもどおりrun_qemu.shで起動させます。</p>\n<p><img src=\"/304/10.png\" alt=\"画像\"></p>\n<h2>エラー処理</h2>\n<p>わざとエラーにしたらきちんとエラー処理されました</p>\n<p><img src=\"/304/11.png\" alt=\"画像\"></p>\n<h2>ポインタとアセンブリの説明</h2>\n<p>ここでの記載は省略します。</p>\n<h2>今後もよく使いそうなコマンドメモ</h2>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">misaka@misaka:~/workspace/mikanos/kernel$ ls\nmain.cpp  usb\nmisaka@misaka:~/workspace/mikanos/kernel$ clang++ $CPPFLAGS --target=x86_64-elf -fno-exceptions -ffreestanding -c main.cpp\nmisaka@misaka:~/workspace/mikanos/kernel$ ld.lld $LDFLAGS --entry KernelMain -z norelro --image-base 0x100000 --static -o kernel.elf main.o\nmisaka@misaka:~/workspace/mikanos/kernel$ ls\nkernel.elf  main.cpp  main.o  usb\n</code></pre></div>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">build\nmisaka@misaka:~/edk2$ $HOME/osbook/devenv/run_qemu.sh Build/MikanLoaderX64/DEBUG_CLANG38/X64/Loader.efi $HOME/workspace/mikanos/kernel/kernel.elf</code></pre></div>\n<h2>感想</h2>\n<p>ここにきてようやく進め方というのがわかってきた感じがする。</p>\n<p>あとはコード理解と、裏でバチバチ動かしてる設定系が気になっているところである。。</p>","slug":"p304"},"__N_SSG":true}