{"pageProps":{"frontMatter":{"title":"Rust | 初心者がオリジナルコンソールアプリのブックマークマンを作成する","date":"2022.08.01","description":"Rust | 初心者がオリジナルコンソールアプリのブックマークマンを作成する","categories":["Rust"]},"content":"<p>みなさん、ブックマークマンというアプリをご存じでしょうか？おそらく聞いたことない人がほとんどだと思います。ブックマークマンとは今からRsutで作るオリジナルコンソールアプリです。</p>\n<p>私はRust初心者なのでご容赦ください。</p>\n<h2>引数を受け取る</h2>\n<p>プロジェクトを作成したらmain.rsを早速修正していきます</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">PS D:\\rust&#x26;gt; cargo new bookmarkman\n     Created binary (application) `bookmarkman` package</code></pre></div>\n<p>引数を受け取る必要があるので引数を受け取ってみます</p>\n<div class=\"remark-highlight\"><pre class=\"language-rs\"><code class=\"language-rs\">use std::env;\nfn main() {\n    let args: Vec&#x26;lt;String&#x26;gt; = env::args().collect();\n    println!(&#x26;quot;{}&#x26;quot;, args[1]);\n}</code></pre></div>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">PS D:\\rust\\bookmarkman&#x26;gt; cargo run myBookmark\n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n     Running `target\\debug\\bookmarkman.exe myBookmark`\nmyBookmark</code></pre></div>\n<ul>\n<li>std::envモジュールを利用することでargs関数から引数を取得できます</li>\n</ul>\n<h2>HashMapを利用する</h2>\n<p>引数の値をargというkeyに対して入れて表示します</p>\n<div class=\"remark-highlight\"><pre class=\"language-rs\"><code class=\"language-rs\">use std::env;\nuse std::collections::HashMap;\nfn main() {\n    let args: Vec&#x26;lt;String&#x26;gt; = env::args().collect();\n    println!(&#x26;quot;{}&#x26;quot;, args[1]);\n\n    let mut map = HashMap::new();\n    map.insert(&#x26;quot;arg&#x26;quot;, &#x26;amp;args[1]);\n    for(key,value) in ↦ {\n        println!(&#x26;quot;{} : {}&#x26;quot;, key, value);\n    }\n}\n</code></pre></div>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">PS D:\\rust\\bookmarkman&#x26;gt; cargo run myBookmark\n   Compiling bookmarkman v0.1.0 (D:\\rust\\bookmarkman)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.85s\n     Running `target\\debug\\bookmarkman.exe myBookmark`\nmyBookmark\narg : myBookmark</code></pre></div>\n<ul>\n<li>map.insert(“arg”, &#x26;args[1]);\n<ul>\n<li>配列のindex=1の参照を渡しています</li>\n</ul>\n</li>\n</ul>\n<h2>値を入力させる</h2>\n<p>引数の値でなくて値を入力させます。具体的に言うと「名前を入力してください」のようなメッセージを表示して、ユーザーからの入力を待つようなプログラムです。</p>\n<p>また引数を受け取る必要がなくなるので、引数を受け取る処理の削除と、HashMapには入力された文字列を格納するようにします</p>\n<div class=\"remark-highlight\"><pre class=\"language-rs\"><code class=\"language-rs\">use std::collections::HashMap;\nuse std::io;\n\nfn main() {\n\n    println!(&#x26;quot;タイトルを入力してください&#x26;quot;);\n\n    let mut input = String::new();\n    io::stdin().read_line(&#x26;amp;mut input).expect(&#x26;quot;Error : faild to read&#x26;quot;);\n\n    println!(&#x26;quot;{}&#x26;quot;,input);\n\n    let mut map = HashMap::new();\n    map.insert(&#x26;quot;arg&#x26;quot;, &#x26;amp;input);\n    for(key,value) in ↦ {\n        println!(&#x26;quot;{} : {}&#x26;quot;, key, value);\n    }\n}</code></pre></div>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">PS D:\\rust\\bookmarkman&#x26;gt; cargo run myBookmark\n   Compiling bookmarkman v0.1.0 (D:\\rust\\bookmarkman)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.68s\n     Running `target\\debug\\bookmarkman.exe myBookmark`\nタイトルを入力してください\nラブライブ！スーパースター！\nラブライブ！スーパースター！\n\narg : ラブライブ！スーパースター！</code></pre></div>\n<ul>\n<li>read_lineの戻り値はio::Resultなのでexpectを使って値を取り出しています\n<ul>\n<li>expectはエラーメッセージを付与できます</li>\n<li>似た機能にunwrapがあります</li>\n<li>io::stdin().read_line(&#x26;mut input).unwrap();でもOK</li>\n</ul>\n</li>\n</ul>\n<h2>ループ</h2>\n<p>複数の値を受け取れるようにloop処理を作成します</p>\n<div class=\"remark-highlight\"><pre class=\"language-rs\"><code class=\"language-rs\">use std::collections::HashMap;\nuse std::io;\n\nfn main() {\n\n    loop{\n        println!(&#x26;quot;タイトルを入力してください&#x26;quot;);\n\n        let mut input = String::new();\n        io::stdin().read_line(&#x26;amp;mut input).unwrap();\n\n        println!(&#x26;quot;{}&#x26;quot;,input);\n\n        let mut map = HashMap::new();\n        map.insert(&#x26;quot;arg&#x26;quot;, &#x26;amp;input);\n        for(key,value) in ↦ {\n            println!(&#x26;quot;{} : {}&#x26;quot;, key, value);\n        }\n    }\n}</code></pre></div>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">PS D:\\rust\\bookmarkman&#x26;gt; cargo run myBookmark\n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n     Running `target\\debug\\bookmarkman.exe myBookmark`\nタイトルを入力してください\nliella!\nliella!\n\narg : liella!\n\nタイトルを入力してください\nkanon\nkanon\n\narg : kanon\n\nタイトルを入力してください</code></pre></div>\n<p>これは終了条件がないので無限ループしますが、</p>\n<h2>コマンドの定義</h2>\n<p>「特定のキーを押したときはアプリケーションを終了する」などの分岐を行うために必要となるコマンドを定義します。何を使ってやるか考えたところEnumを使ってコマンドの種類を定義しておく方法にしました。</p>\n<p>ちょっと長くなりますが以下のように実装</p>\n<div class=\"remark-highlight\"><pre class=\"language-rs\"><code class=\"language-rs\">use std::collections::HashMap;\nuse std::io;\n\nenum Command {\n    CONTINUE,\n    EXIT,  \n}\n\n//　数値が入ったOptionからCommandが入ったResultを返します。\nfn get_command(input : Option&#x26;lt;i8&#x26;gt;) -&#x26;gt; Result&#x26;lt;Command,String&#x26;gt; {\n    match input {\n        Some(1) =&#x26;gt; Ok(Command::CONTINUE),\n        Some(2) =&#x26;gt; Ok(Command::EXIT),\n        Some(_) =&#x26;gt; Err(&#x26;quot;入力されたコマンドが存在しません&#x26;quot;.to_string()),\n        None =&#x26;gt; Err(&#x26;quot;システム例外&#x26;quot;.to_string()),\n    }\n}\n\nfn hoge() {\n\n}\n\nfn main() {\n\n    loop{\n\n        println!(&#x26;quot;コマンドを入力してください&#x26;quot;);\n        println!(&#x26;quot;1 = ブックマークを登録する&#x26;quot;);\n        println!(&#x26;quot;2 = アプリケーションを終了する&#x26;quot;);\n\n        // ユーザーからコマンド番号を受け取る\n        let mut input = String::new();\n        io::stdin().read_line(&#x26;amp;mut input).unwrap();\n\n        // コマンド番号をOption&#x26;lt;i8&#x26;gt;に変換する\n        let command_num : Option&#x26;lt;i8&#x26;gt; = match input.trim().parse() {\n            Ok(num) =&#x26;gt; Some(num),\n            Err(_) =&#x26;gt; {\n                println!(&#x26;quot;存在しないコマンドが入力されました&#x26;quot;);\n                break\n            },\n        };\n\n        // 数値からResult&#x26;lt;Command&#x26;gt;というenumを取得する\n        let command_enum = get_command(command_num);\n\n        // Result&#x26;lt;&#x26;gt;なので中身(enum)をmatchにかける\n        match command_enum.unwrap() {\n            Command::CONTINUE =&#x26;gt; hoge(),\n            Command::EXIT =&#x26;gt; {\n                println!(&#x26;quot;アプリケーションを終了します&#x26;quot;);\n                break\n            }\n        }\n    \n        let mut map = HashMap::new();\n        map.insert(&#x26;quot;arg&#x26;quot;, &#x26;amp;input);\n        for(key,value) in ↦ {\n            println!(&#x26;quot;{} : {}&#x26;quot;, key, value);\n        }\n    }\n}\n</code></pre></div>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">PS D:\\rust\\bookmarkman&#x26;gt; cargo run \n   Compiling bookmarkman v0.1.0 (D:\\rust\\bookmarkman)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.57s\n     Running `target\\debug\\bookmarkman.exe`\nコマンドを入力してください\n1 = ブックマークを登録する\n2 = アプリケーションを終了する\n1\narg : 1\n\nコマンドを入力してください\n1 = ブックマークを登録する\n2 = アプリケーションを終了する\n2\nアプリケーションを終了します</code></pre></div>\n<p>入力された値に応じて処理を振り分けることに成功しました。またループを抜けることもできるようになりました。</p>\n<h2>HashMapに登録する処理</h2>\n<p>HashMapなので同じキーが使えないのでここは後で修正しますが、いったんはイメージとしてこんな感じで書きます</p>\n<div class=\"remark-highlight\"><pre class=\"language-rs\"><code class=\"language-rs\">use std::collections::HashMap;\nuse std::io;\n\nenum Command {\n    CONTINUE,\n    EXIT,  \n}\n//　数値が入ったOptionからCommandが入ったResultを返します。\nfn get_command(input : Option&#x26;lt;i8&#x26;gt;) -&#x26;gt; Result&#x26;lt;Command,String&#x26;gt; {\n    match input {\n        Some(1) =&#x26;gt; Ok(Command::CONTINUE),\n        Some(2) =&#x26;gt; Ok(Command::EXIT),\n        Some(_) =&#x26;gt; Err(&#x26;quot;入力されたコマンドが存在しません&#x26;quot;.to_string()),\n        None =&#x26;gt; Err(&#x26;quot;システム例外&#x26;quot;.to_string()),\n    }\n}\n\nfn register_bookmark(map : &#x26;amp;mut HashMap&#x26;lt;String,String&#x26;gt;) {\n    // コマンドからブックマークのURLを受け取る\n    println!(&#x26;quot;URLを入力してください&#x26;quot;);\n    let mut url = String::new();\n    io::stdin().read_line(&#x26;amp;mut url).unwrap();\n\n    // コマンドからブックマークのタイトルを受け取る\n    println!(&#x26;quot;タイトルを入力してください&#x26;quot;);\n    let mut title = String::new();\n    io::stdin().read_line(&#x26;amp;mut title).unwrap();\n\n    // HashMapに受け取った値を登録する\n    map.insert(&#x26;quot;URL&#x26;quot;.to_string(), url);\n    map.insert(&#x26;quot;TITLE&#x26;quot;.to_string(), title);\n\n}\n\nfn main() {\n\n    // ブックマーク格納するHashMap\n    let mut map :HashMap&#x26;lt;String,String&#x26;gt; = HashMap::new();\n\n    loop{ \n        println!(&#x26;quot;コマンドを入力してください&#x26;quot;);\n        println!(&#x26;quot;1 = ブックマークを登録する&#x26;quot;);\n        println!(&#x26;quot;2 = アプリケーションを終了する&#x26;quot;);\n\n        // ユーザーからコマンド番号を受け取る\n        let mut input = String::new();\n        io::stdin().read_line(&#x26;amp;mut input).unwrap();\n\n        // コマンド番号をOption&#x26;lt;i8&#x26;gt;に変換する\n        let command_num : Option&#x26;lt;i8&#x26;gt; = match input.trim().parse() {\n            Ok(num) =&#x26;gt; Some(num),\n            Err(_) =&#x26;gt; {\n                println!(&#x26;quot;存在しないコマンドが入力されました&#x26;quot;);\n                break\n            },\n        };\n\n        // 数値からResult&#x26;lt;Command&#x26;gt;というenumを取得する\n        let command_enum = get_command(command_num);\n\n        // Result&#x26;lt;&#x26;gt;なので中身(enum)をmatchにかける\n        match command_enum.unwrap() {\n            Command::CONTINUE =&#x26;gt; register_bookmark(&#x26;amp;mut map), \n            Command::EXIT =&#x26;gt; {\n                println!(&#x26;quot;アプリケーションを終了します&#x26;quot;);\n                break\n            }\n        }\n    \n       // let mut map = HashMap::new();\n       /*\n        map.insert(&#x26;quot;arg&#x26;quot;, &#x26;amp;input);\n        for(key,value) in ↦ {\n            println!(&#x26;quot;{} : {}&#x26;quot;, key, value);\n        }\n        */\n    }\n\n}</code></pre></div>\n<ul>\n<li>コマンドの1を入力した時にregister_bookmark関数が実行されます\n<ul>\n<li>この時引数に可変参照のHashMapを受け取るようにします</li>\n<li>呼び出し側も&#x26;mutとしてあげます</li>\n</ul>\n</li>\n</ul>\n<h2>構造体の作成</h2>\n<p>HashMapでは同じキーを登録できないのでURLもタイトルも1つしか登録ができません。なのでブックマークという構造体を作成して、ベクタ(サイズ可変)にどんどん突っ込めるようにします。</p>\n<p>削除個所をコメントアウトしているので、少し長くなっています</p>\n<div class=\"remark-highlight\"><pre class=\"language-rs\"><code class=\"language-rs\">use std::collections::HashMap;\nuse std::io;\n\nenum Command {\n    CONTINUE,\n    EXIT,  \n}\n\n// ブックマークを表す構造体を定義する\nstruct Bookmark {\n    url : String,\n    title: String,\n}\n\n//　数値が入ったOptionからCommandが入ったResultを返します。\nfn get_command(input : Option&#x26;lt;i8&#x26;gt;) -&#x26;gt; Result&#x26;lt;Command,String&#x26;gt; {\n    match input {\n        Some(1) =&#x26;gt; Ok(Command::CONTINUE),\n        Some(2) =&#x26;gt; Ok(Command::EXIT),\n        Some(_) =&#x26;gt; Err(&#x26;quot;入力されたコマンドが存在しません&#x26;quot;.to_string()),\n        None =&#x26;gt; Err(&#x26;quot;システム例外&#x26;quot;.to_string()),\n    }\n}\n\n/*\nfn register_bookmark(map : &#x26;amp;mut HashMap&#x26;lt;String,String&#x26;gt;) {\n    // コマンドからブックマークのURLを受け取る\n    println!(&#x26;quot;URLを入力してください&#x26;quot;);\n    let mut url = String::new();\n    io::stdin().read_line(&#x26;amp;mut url).unwrap();\n\n    // コマンドからブックマークのタイトルを受け取る\n    println!(&#x26;quot;タイトルを入力してください&#x26;quot;);\n    let mut title = String::new();\n    io::stdin().read_line(&#x26;amp;mut title).unwrap();\n\n    // HashMapに受け取った値を登録する\n    map.insert(&#x26;quot;URL&#x26;quot;.to_string(), url);\n    map.insert(&#x26;quot;TITLE&#x26;quot;.to_string(), title);\n}\n*/\n\n\nfn register_bookmark(bookmarks : &#x26;amp;mut Vec&#x26;lt;Bookmark&#x26;gt;) {\n    // コマンドからブックマークのURLを受け取る\n    println!(&#x26;quot;URLを入力してください&#x26;quot;);\n    let mut url = String::new();\n    io::stdin().read_line(&#x26;amp;mut url).unwrap();\n\n    // コマンドからブックマークのタイトルを受け取る\n    println!(&#x26;quot;タイトルを入力してください&#x26;quot;);\n    let mut title = String::new();\n    io::stdin().read_line(&#x26;amp;mut title).unwrap();\n\n    // ブックマークを作成する\n    let bookmark = Bookmark {\n        url,\n        title,\n    };\n\n    // HashMapに受け取った値を登録する(もちろん可変じゃないと登録はできません)\n    bookmarks.push(bookmark);\n}\n\n\nfn main() {\n\n    // ブックマーク格納するHashMap\n    //let mut map :HashMap&#x26;lt;String,String&#x26;gt; = HashMap::new();\n\n    // ブックマークを格納するVec&#x26;lt;Bookmark&#x26;gt;\n    let mut bookmarks : Vec&#x26;lt;Bookmark&#x26;gt; = Vec::new();\n\n    loop{ \n        println!(&#x26;quot;コマンドを入力してください&#x26;quot;);\n        println!(&#x26;quot;1 = ブックマークを登録する&#x26;quot;);\n        println!(&#x26;quot;2 = アプリケーションを終了する&#x26;quot;);\n\n        // ユーザーからコマンド番号を受け取る\n        let mut input = String::new();\n        io::stdin().read_line(&#x26;amp;mut input).unwrap();\n\n        // コマンド番号をOption&#x26;lt;i8&#x26;gt;に変換する\n        let command_num : Option&#x26;lt;i8&#x26;gt; = match input.trim().parse() {\n            Ok(num) =&#x26;gt; Some(num),\n            Err(_) =&#x26;gt; {\n                println!(&#x26;quot;存在しないコマンドが入力されました&#x26;quot;);\n                break\n            },\n        };\n\n        // 数値からResult&#x26;lt;Command&#x26;gt;というenumを取得する\n        let command_enum = get_command(command_num);\n\n        // Result&#x26;lt;&#x26;gt;なので中身(enum)をmatchにかける\n        match command_enum.unwrap() {\n            // Vecに格納する関数に変更する\n            //Command::CONTINUE =&#x26;gt; register_bookmark(&#x26;amp;mut map), \n            Command::CONTINUE =&#x26;gt; register_bookmark(&#x26;amp;mut bookmarks), \n            Command::EXIT =&#x26;gt; {\n                println!(&#x26;quot;アプリケーションを終了します&#x26;quot;);\n                break\n            }\n        }\n    \n       // let mut map = HashMap::new();\n       /*\n        map.insert(&#x26;quot;arg&#x26;quot;, &#x26;amp;input);\n        for(key,value) in ↦ {\n            println!(&#x26;quot;{} : {}&#x26;quot;, key, value);\n        }\n        */\n    }\n}\n</code></pre></div>\n<ul>\n<li>考え方はHashMapと同じです</li>\n</ul>\n<h2>構造体をデバッグ出力する</h2>\n<p>構造体をログに出力できるようにします。</p>\n<div class=\"remark-highlight\"><pre class=\"language-rs\"><code class=\"language-rs\">use std::io;\n\nenum Command {\n    CONTINUE,\n    EXIT,  \n}\n\n// ブックマークを表す構造体を定義する\n// #[derive(Debug)]をつけると{:?}でログに出力できるようになります\n#[derive(Debug)]\nstruct Bookmark {\n    url : String,\n    title: String,\n}\n\n//　数値が入ったOptionからCommandが入ったResultを返します。\nfn get_command(input : Option&#x26;lt;i8&#x26;gt;) -&#x26;gt; Result&#x26;lt;Command,String&#x26;gt; {\n    match input {\n        Some(1) =&#x26;gt; Ok(Command::CONTINUE),\n        Some(2) =&#x26;gt; Ok(Command::EXIT),\n        Some(_) =&#x26;gt; Err(&#x26;quot;入力されたコマンドが存在しません&#x26;quot;.to_string()),\n        None =&#x26;gt; Err(&#x26;quot;システム例外&#x26;quot;.to_string()),\n    }\n}\n\nfn register_bookmark(bookmarks : &#x26;amp;mut Vec&#x26;lt;Bookmark&#x26;gt;) {\n    // コマンドからブックマークのURLを受け取る\n    println!(&#x26;quot;URLを入力してください&#x26;quot;);\n    let mut url = String::new();\n    io::stdin().read_line(&#x26;amp;mut url).unwrap();\n\n    // コマンドからブックマークのタイトルを受け取る\n    println!(&#x26;quot;タイトルを入力してください&#x26;quot;);\n    let mut title = String::new();\n    io::stdin().read_line(&#x26;amp;mut title).unwrap();\n\n    // ブックマークを作成する\n    let bookmark = Bookmark {\n        url,\n        title,\n    };\n\n    // HashMapに受け取った値を登録する(もちろん可変じゃないと登録はできません)\n    bookmarks.push(bookmark);\n}\n\n\nfn main() {\n\n    // ブックマークを格納するVec&#x26;lt;Bookmark&#x26;gt;\n    let mut bookmarks : Vec&#x26;lt;Bookmark&#x26;gt; = Vec::new();\n\n    loop{ \n        println!(&#x26;quot;コマンドを入力してください&#x26;quot;);\n        println!(&#x26;quot;1 = ブックマークを登録する&#x26;quot;);\n        println!(&#x26;quot;2 = アプリケーションを終了する&#x26;quot;);\n\n        // ユーザーからコマンド番号を受け取る\n        let mut input = String::new();\n        io::stdin().read_line(&#x26;amp;mut input).unwrap();\n\n        // コマンド番号をOption&#x26;lt;i8&#x26;gt;に変換する\n        let command_num : Option&#x26;lt;i8&#x26;gt; = match input.trim().parse() {\n            Ok(num) =&#x26;gt; Some(num),\n            Err(_) =&#x26;gt; {\n                println!(&#x26;quot;存在しないコマンドが入力されました&#x26;quot;);\n                break\n            },\n        };\n\n        // 数値からResult&#x26;lt;Command&#x26;gt;というenumを取得する\n        let command_enum = get_command(command_num);\n\n        // Result&#x26;lt;&#x26;gt;なので中身(enum)をmatchにかける\n        match command_enum.unwrap() {\n            Command::CONTINUE =&#x26;gt; register_bookmark(&#x26;amp;mut bookmarks), \n            Command::EXIT =&#x26;gt; {\n                println!(&#x26;quot;アプリケーションを終了します&#x26;quot;);\n                break\n            }\n        }\n\n    }\n\n    for bookmark in &#x26;amp;bookmarks {\n        println!(&#x26;quot;{:?}&#x26;quot;, bookmark);\n    }\n\n}</code></pre></div>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">undefined</code></pre></div>","slug":"p3188"},"__N_SSG":true}